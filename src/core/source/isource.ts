/// <reference path="../../../defs/es6-promise.d.ts" />

import {Source} from './source';
import {App as iApp} from '../../internal/app';
import {Item as iItem} from '../../internal/item';
import {
  minVersion,
  versionCompare,
  getVersion,
  globalsrcMinVersion
} from '../../internal/util/version';
import {XML} from '../../internal/util/xml';
import {JSON as JXON} from '../../internal/util/json';
import {Environment} from '../environment';
import {Scene} from '../scene';
import {Logger} from '../../internal/util/logger';

/**
 * ItemTypes is used to define the type of the current Source.
 *
 * Check `getType()` method of {@link #core/Source#getType Core/Source}
 */
export enum ItemTypes {
  UNDEFINED,
  FILE,
  LIVE,
  TEXT,
  BITMAP,
  SCREEN,
  FLASHFILE,
  GAMESOURCE,
  HTML,
  THREEDS,
  PPTFILE,
  SCENE,
  GROUP,
  REPLAY,
  VIEW
}

export interface ISource {
  /**
   * param: (value: string)
   * ```
   * return: Promise<ISource>
   * ```
   *
   * In XBC 2.8, names can be set individually even on linked items.
   * For XBC 2.9 onwards,  name will be the same across all linked items
   * to the same Source.
   *
   * *Chainable.*
   *
   * #### Usage
   *
   * ```javascript
   * source.setName('newNameHere').then(function(source) {
   *   // Promise resolves with same Source instance when name has been set
   *   return source.getName();
   * }).then(function(name) {
   *   // 'name' should be the updated value by now.
   * });
   * ```
   */
  setName(value: string): Promise<ISource>

  /**
   * return: Promise<string>
   *
   * Gets the name of the source.
   *
   * #### Usage
   *
   * ```javascript
   * source.getName().then(function(name) {
   *   // Do something with the name
   * });
   * ```
   */
  getName(): Promise<string>

  /**
   * param: (value: string)
   * ```
   * return: Promise<ISource>
   * ```
   *
   * In XBC 2.8, CustomName can be set individually even on linked items.
   * For XBC 2.9 onwards, CustomName will be the same across all linked items
   * to the same Source
   *
   * The main difference between `setName` and `setCustomName` is that the CustomName
   * can be edited by users using XBC through the bottom panel. `setName` on
   * the other hand would update the sources internal name property.
   *
   * *Chainable.*
   *
   * #### Usage
   *
   * ```javascript
   * source.setCustomName('newNameHere').then(function(source) {
   *   // Promise resolves with same Source instance when custom name has been set
   *   return source.getCustomName();
   * }).then(function(name) {
   *   // 'name' should be the updated value by now.
   * });
   * ```
   */
  setCustomName(string): Promise<ISource>

  /**
   * return: Promise<string>
   *
   * Gets the Source custom name
   */  /**
   * return: Promise<string>
   *
   * Gets the custom name of the source.
   *
   * #### Usage
   *
   * ```javascript
   * source.getCustomName().then(function(name) {
   *   // Do something with the name
   * });
   * ```
   */
  getCustomName(): Promise<string>

  /**
   * return: Promise<string|XML>
   *
   * Gets a special string that refers to the source's main definition.
   *
   * This method can resolve with an XML object, which is an object generated by
   * the framework. Call `toString()` to transform into an XML String. (See the
   * documentation for `setValue` for more details.)
   *
   * #### Usage
   *
   * ```javascript
   * source.getValue().then(function(value) {
   *   // Do something with the value
   * });
   * ```
   */
  getValue(): Promise<string|XML>

  /**
   * param: (value: string)
   * ```
   * return: Promise<ISource>
   * ```
   *
   * Set the sources main definition. This special string defines the sources
   * "identity". Each type of source requires a different format for this value.
   *
   * *Chainable.*
   *
   * **WARNING:**
   * Please do note that using this method COULD break the current source, possibly modifying
   * its type IF you set an invalid string for the current source.
   *
   * #### Possible values by source type
   * - FILE - path/URL
   * - LIVE - Device ID
   * - BITMAP - path
   * - SCREEN - XML string
   * - FLASHFILE - path
   * - GAMESOURCE - XML string
   * - HTML - path/URL or html:<plugin>
   *
   * #### Usage
   *
   * ```javascript
   * source.setValue('@DEVICE:PNP:\\?\USB#VID_046D&amp;PID_082C&amp;MI_02#6&amp;16FD2F8D&amp;0&amp;0002#{65E8773D-8F56-11D0-A3B9-00A0C9223196}\GLOBAL')
   *   .then(function(source) {
   *   // Promise resolves with same Source instance
   * });
   * ```
   */
  setValue(string): Promise<ISource>

  /**
   * return: Promise<boolean>
   *
   * Check if source is kept loaded in memory
   *
   * #### Usage
   *
   * ```javascript
   * source.getKeepLoaded().then(function(isLoaded) {
   *   // The rest of your code here
   * });
   * ```
   */
  getKeepLoaded(): Promise<boolean>

  /**
   * param: (value: boolean)
   * ```
   * return: Promise<ISource>
   * ```
   *
   * Set Keep loaded option to ON or OFF
   *
   * Sources with Keep loaded set to ON would emit `scene-load` event each time
   * the active scene switches to the source's current scene.
   *
   * *Chainable.*
   *
   * #### Usage
   *
   * ```javascript
   * source.setKeepLoaded(true).then(function(source) {
   *   // Promise resolves with same Source instance
   * });
   * ```
   */
  setKeepLoaded(boolean): Promise<ISource>

  /**
   * return: Promise<string>
   *
   * Get the Source ID of the source.
   * *Available only on XSplit Broadcaster versions higher than 2.8.1603.0401*
   *
   * #### Usage
   *
   * ```javascript
   * source.getId().then(function(id) {
   *   // The rest of your code here
   * });
   * ```
   */
  getId(): Promise<string>

  /**
   *  return: Promise<ISource>
   *
   *  Refreshes the specified Source.
   *
   *  #### Usage
   *  ```javascript
   *  // Sample 1: let source refresh itself
   *  xjs.Source.getCurrentSource().then(function(source) {
   *    source.refresh(); // execution of JavaScript halts because of refresh
   *  });
   *
   *  // Sample 2: refresh some other source 'otherSource'
   *  otherSource.refresh().then(function(source) {
   *    // further manipulation of other source goes here
   *  });
   *  ```
   */
  refresh(): Promise<ISource>

  /**
   * return: Promise<Item[]>
   *
   * Get the item list of the current Source/Item instance. This is useful when
   * a source has multiple items linked into it or if an item is an instance of
   * a linked item.
   *
   * #### Usage
   *
   * ```javascript
   * // source pertains to an actual source instance
   * // Sample 1
   * source.getItemList().then(function(items) {
   *   // This will fetch the linked items list of the current source
   *   for (var i = 0 ; i < items.length ; i++) {
   *     // Manipulate each item here
   *     items[0].getSceneId();
   *   }
   * });
   *
   * // Sample 2
   * item.getItemList().then(function(items) {
   *   items[0].getSceneId();
   * })
   * ```
   */
  getItemList(): Promise<ISource[]>

  /**
   * return: Promise<ItemType>
   *
   * Get the type of the source
   *
   * #### Usage
   *
   * ```javascript
   * source.getType().then(function(type) {
   *   // The rest of your code here
   * });
   * ```
   */
  getType(): Promise<number>

}

/**
 * Used by Source and Item to implement methods that are used on both classes
 * More info to be added soon.
 */

export class iSource implements ISource{
  private _id: string;
  private _value: any;
  private _name: string;
  private _cname: string;
  private _keepLoaded: boolean;
  private _globalsrc: boolean;
  private _isItemCall: boolean;
  private _type: ItemTypes;
  private _sceneId: string;
  private _srcId: string;
  private _checkPromise;

  private _updateId(id?: string, sceneId?: string) {
    this._id = id;
    this._sceneId = sceneId;
  }

  setName(value: string): Promise <iSource> {
    return new Promise(resolve => {
      this._name = value;

      if (
        versionCompare(getVersion())
          .is
          .lessThan(minVersion)
      ) {
        iItem.set('prop:name', this._name, this._id).then(() => {
          resolve(this);
        });
      } else {
        if (this._isItemCall) {
          Logger.warn('sourceWarning', 'setName', true)
          iItem.set('prop:name', this._name, this._id)
          .then(() => {
            resolve(this);
          });
        } else {
          iItem.wrapSet('prop:name', this._name, this._srcId, this._id, this._updateId.bind(this))
          .then(() => {
            resolve(this);
          });
        }
      }
    });
  }

  getName(): Promise<string> {
    return new Promise(resolve => {
      if(this._isItemCall){
        Logger.warn('sourceWarning', 'getName',  true)
        this._checkPromise = iItem.get('prop:name', this._id)
      } else {
        this._checkPromise = iItem.wrapGet('prop:name', this._srcId,
          this._id, this._updateId.bind(this))
      }
      this._checkPromise.then(val => {
        this._name = String(val);
        resolve(val);
      });
    });
  }

  setCustomName(value: string): Promise<ISource> {
    return new Promise(resolve => {
      this._cname = value;
      if(this._isItemCall){
        Logger.warn('sourceWarning', 'setCustomName', true)
        iItem.set('prop:cname', this._cname, this._id)
        .then(() => {
          resolve(this);
        });
      } else {
        iItem.wrapSet('prop:cname', this._cname, this._srcId, this._id, this._updateId.bind(this))
        .then(() => {
          resolve(this);
        });
      }
    });
  }

  getCustomName(): Promise<string> {
    return new Promise(resolve => {
      if(this._isItemCall){
        Logger.warn('sourceWarning', 'getCustomName', true)
        iItem.get('prop:cname', this._id)
        .then(val => {
          resolve(val);
        });
      } else {
        iItem.wrapGet('prop:cname', this._srcId,
          this._id, this._updateId.bind(this))
        .then(val => {
          resolve(val);
        });
      }
    });
  }

  getValue(): Promise<string | XML> {
    return new Promise(resolve => {
      if(this._isItemCall){
        Logger.warn('sourceWarning', 'getValue', true)
        this._checkPromise = iItem.get('prop:item', this._id)
      } else {
        this._checkPromise = iItem.wrapGet('prop:item', this._srcId,
          this._id, this._updateId.bind(this))
      }
      this._checkPromise.then(val => {
        val = (val === 'null') ? '' : val;
        if (val === '') { // don't return XML for null values
          this._value = '';
          resolve(val);
        } else {
          try {
            this._value = XML.parseJSON(JXON.parse(val));
            resolve(this._value);
          } catch (e) {
            // value is not valid XML (it is a string instead)
            this._value = val;
            resolve(val);
          }
        }
      });
    });
  }

  setValue(value: string | XML): Promise<ISource> {
    return new Promise((resolve, reject) => {
      var prevVal
      var val: string = (typeof value === 'string') ?
      <string>value : (<XML>value).toString();
      if (typeof value !== 'string') { // XML
        this._value = JXON.parse(val);
      } else {
        this._value = val;
      }

      let typeCheck = this.getValue().then(origVal => {
        return new Promise((typeRes, typeRej) => {
          if (String(origVal).toUpperCase().indexOf('{33D9A762-90C8-11D0-BD43-00A0C911CE86}') !== -1 &&
            val.toUpperCase().indexOf('{33D9A762-90C8-11D0-BD43-00A0C911CE86}') === -1 &&
            this._type === ItemTypes.LIVE) {
              typeRej(Error('Value is not a valid Audio source'))
          } else {
            typeRes(true)
          }
        })
      })

      typeCheck.then(() => {
        if(this._isItemCall){
          Logger.warn('sourceWarning', 'setValue', true)
          iItem.set(String(this._type) === '2' ? 'prop:item' : 'prop:srcitem' , val, this._id)
          .then(() => {
            resolve(this);
          });
        } else {
          iItem.wrapSet('prop:srcitem', val, this._srcId, this._id, this._updateId.bind(this))
          .then(() => {
            resolve(this);
          });
        }
      })
    });
  }

  getKeepLoaded(): Promise<boolean> {
    return new Promise(resolve => {
      if(this._isItemCall){
        Logger.warn('sourceWarning', 'getKeepLoaded', true)
        this._checkPromise = iItem.get('prop:keeploaded', this._id)
      } else {
        this._checkPromise = iItem.wrapGet('prop:keeploaded', this._srcId,
          this._id, this._updateId.bind(this))
      }
      this._checkPromise.then(val => {
          this._keepLoaded = (val === '1');
          resolve(this._keepLoaded);
        });
    });
  }

  setKeepLoaded(value: boolean): Promise<ISource> {
    return new Promise(resolve => {
      this._keepLoaded = value;
      this._globalsrc = value;
      if(versionCompare(getVersion())
        .is
        .lessThan(globalsrcMinVersion)) {
        iItem.set('prop:globalsrc', (this._globalsrc ? '1' : '0'), this._id)
      }
      if(this._isItemCall){
        Logger.warn('sourceWarning', 'setKeepLoaded', true)
        iItem.set('prop:keeploaded', (this._keepLoaded ? '1' : '0'), this._id)
        .then(() => {
          resolve(this);
        });
      } else {
        iItem.wrapSet('prop:keeploaded', (this._keepLoaded ? '1' : '0'),
          this._srcId, this._id, this._updateId.bind(this))
        .then(() => {
          resolve(this);
        });
      }
    });
  }

  getId(): Promise<string> {
    return new Promise((resolve, reject) => {
      if (this._isItemCall) {
        resolve(this._id)
      } else {
        if (versionCompare(getVersion()).is.lessThan(minVersion)) {
          reject(Error('Only available on versions above ' + minVersion));
        } else {
        iItem.wrapGet('prop:srcid', this._srcId, this._id, this._updateId.bind(this))
        .then(srcid => {
            resolve(srcid);
          });
        }
      }
    });
  }

  refresh(): Promise<iSource> {
    return new Promise(resolve => {
      if (this._isItemCall) {
        iItem.set('refresh', '', this._id).then(() => {
          resolve(this);
        });
      } else {
        iItem.wrapSet('refresh', '', this._srcId, this._id,
          this._updateId.bind(this)).then(() => {
          resolve(this);
        });
      }
    });
  }

  getItemList(): Promise<iSource[]> {
    return new Promise((resolve, reject) => {
      if (
        versionCompare(getVersion())
          .is
          .lessThan(minVersion)
      ) {
        Scene.searchItemsById(this._id).then(item => {
          const itemArray = [];
          itemArray.push(item);
          resolve(itemArray);
        });
      } else {
        if (this._isItemCall) {
          this._checkPromise = iItem.get('itemlist', this._id)
        } else {
          this._checkPromise = iItem.wrapGet('itemlist', this._srcId,
            this._id, this._updateId.bind(this))
        }
        this._checkPromise.then(itemlist => {
          const promiseArray: Promise<iSource>[] = [];
          const itemsArray = String(itemlist).split(',');

          itemsArray.forEach(itemId => {
            promiseArray.push(new Promise(itemResolve => {
              Scene.searchItemsById(itemId).then(item => {
                itemResolve(item);
              }).catch(() => itemResolve(null));
            }));
          });

          Promise.all(promiseArray).then(results => {
            resolve(results.filter(res => res !== null));
          });
        });
      }
    })
  }

  getType(): Promise<number> {
    return new Promise(resolve => {
      if(this._isItemCall) {
        this._checkPromise = iItem.get('prop:type', this._id)
      } else {
        this._checkPromise = iItem.wrapGet('prop:type', this._srcId,
          this._id, this._updateId.bind(this))
      }
      this._checkPromise.then(val => {
        this._type = ItemTypes[ItemTypes[Number(val)]];
        resolve(this._type);
      });
    });
  }

}